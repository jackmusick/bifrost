"""
Generate a synthetic large Python module for memory testing.

This creates a ~4MB Python file that resembles real workflow modules
like halopsa.py to test memory behavior during sync operations.
"""


def generate_large_module(target_size_mb: float = 4.0) -> str:
    """
    Generate a synthetic Python module of approximately target_size_mb.

    The generated code is syntactically valid Python with realistic
    workflow-like structures (functions, docstrings, type hints).
    """
    target_bytes = int(target_size_mb * 1024 * 1024)
    parts: list[str] = []

    # Module header
    parts.append('"""')
    parts.append("Large synthetic workflow module for memory testing.")
    parts.append("")
    parts.append("This file is auto-generated by large_module_generator.py")
    parts.append("to simulate large real-world modules like halopsa.py (~4MB).")
    parts.append('"""')
    parts.append("")
    parts.append("import logging")
    parts.append("from typing import Any")
    parts.append("")
    parts.append("logger = logging.getLogger(__name__)")
    parts.append("")

    # Generate functions until we reach target size
    func_num = 0
    while len("\n".join(parts)) < target_bytes:
        func_num += 1
        func_name = f"workflow_function_{func_num:04d}"

        # Each function is ~2KB with docstring and realistic code
        func_lines = [
            f"def {func_name}(",
            "    param1: str,",
            "    param2: int,",
            "    param3: dict[str, Any] | None = None,",
            ") -> dict[str, Any]:",
            '    """',
            f"    Process data using workflow function {func_num}.",
            "",
            "    This function handles data transformation and validation",
            "    for the integration pipeline. It processes incoming records",
            "    and returns the transformed result.",
            "",
            "    Args:",
            "        param1: The primary identifier string",
            "        param2: A numeric value for processing",
            "        param3: Optional configuration dictionary",
            "",
            "    Returns:",
            "        Dictionary containing processed results",
            "",
            "    Raises:",
            "        ValueError: If param1 is empty",
            "        TypeError: If param2 is negative",
            '    """',
            f'    logger.debug("Executing {func_name} with param1=%s", param1)',
            "",
            "    if not param1:",
            '        raise ValueError("param1 cannot be empty")',
            "",
            "    if param2 < 0:",
            '        raise TypeError("param2 must be non-negative")',
            "",
            "    config = param3 or {}",
            "",
            "    # Process the data with multiple transformations",
            "    result: dict[str, Any] = {",
            '        "id": param1,',
            '        "value": param2 * 2,',
            '        "status": "processed",',
            '        "metadata": {',
            f'            "function": "{func_name}",',
            '            "version": "1.0.0",',
            "            \"config_keys\": list(config.keys()),",
            "        },",
            "    }",
            "",
            "    # Add computed fields based on configuration",
            '    if config.get("include_details"):',
            '        result["details"] = {',
            '            "param1_length": len(param1),',
            '            "param2_doubled": param2 * 2,',
            '            "param2_squared": param2 ** 2,',
            "        }",
            "",
            '    if config.get("include_timestamps"):',
            "        from datetime import datetime, timezone",
            '        result["timestamps"] = {',
            '            "processed_at": datetime.now(timezone.utc).isoformat(),',
            "        }",
            "",
            f'    logger.info("{func_name} completed successfully")',
            "    return result",
            "",
            "",
        ]
        parts.extend(func_lines)

    return "\n".join(parts)


def generate_large_module_file(path: str, target_size_mb: float = 4.0) -> None:
    """Write the generated module to a file."""
    content = generate_large_module(target_size_mb)
    with open(path, "w") as f:
        f.write(content)


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        output_path = sys.argv[1]
    else:
        output_path = "large_module.py"

    generate_large_module_file(output_path)
    print(f"Generated {output_path}")
