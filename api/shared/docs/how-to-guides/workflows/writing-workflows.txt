# Write Workflows

Complete guide to writing Bifrost workflows with decorators, parameters, and best practices

---

Steps,
    Aside,
    Tabs,
    TabItem,
    Card,
    CardGrid,
} from "@astrojs/starlight/components";

## Basic Structure

Every workflow follows this pattern:

```python
from bifrost import workflow
import logging

logger = logging.getLogger(__name__)

@workflow(category="Category Name")
async def my_workflow(param1: str, param2: int = 10):
    """Docstring explaining workflow purpose - this becomes the description."""
    logger.info(f"Processing {param1}")
    return {"result": "success"}
```

The decorator automatically infers:
- **name**: from the function name (`my_workflow`)
- **description**: from the docstring
- **parameters**: from the function signature with type hints

## Decorator Reference

### @workflow Options

All options are optional - the decorator infers name and description from your function.

  

**name** (str)
: Auto-derived from function name if not provided

**description** (str)
: Auto-derived from docstring if not provided

**execution_mode** (str)
: Auto-selected based on `endpoint_enabled`

  
  

**category** (str)
: Grouping category (default: "General")

**tags** (list)
: List of tags for filtering

**timeout_seconds** (int)
: Max execution time (default: 1800 = 30 min)

**schedule** (str)
: Cron expression for scheduled runs

**endpoint_enabled** (bool)
: Expose as HTTP endpoint (default: False)

  

### Parameter Inference

Parameters are automatically extracted from your function signature:

```python
@workflow
async def create_user(
    email: str,              # Required string, label: "Email"
    name: str,               # Required string, label: "Name"
    department: str = "IT",  # Optional with default
    active: bool = True      # Optional boolean
):
    """Create a new user."""
    pass
```

### Type Hint Support

The following Python types are supported for parameters:

```python
@workflow
async def example(
    name: str,                     # Text input
    count: int,                    # Integer input
    amount: float,                 # Decimal input
    enabled: bool = False,         # Boolean toggle
    tags: list[str] | None = None, # List of strings
    config: dict | None = None,    # JSON object
) -> dict:
    """Example with various parameter types."""
    ...
```

### Literal Types for Options

Use `Literal` to create dropdown selections:

```python
from typing import Literal

@workflow
async def create_user(
    email: str,
    role: Literal["admin", "user", "guest"] = "user",
    status: Literal["active", "inactive"] = "active",
) -> dict:
    """Create a user with predefined options."""
    ...
```

## Execution Context

Access organization, user, and execution metadata:

```python
async def my_workflow(context: ExecutionContext):
    # Organization
    org_id = context.org_id
    org_name = context.org_name

    # User
    user_id = context.user_id
    user_email = context.email
    user_name = context.name

    # Execution
    execution_id = context.execution_id
    is_admin = context.is_platform_admin
    is_global = context.is_global_scope
```

## SDK Modules

Access config, integrations, and files via SDK. All methods are async:

```python
from bifrost import config, integrations, files

async def my_workflow():
    """Example workflow using SDK modules."""
    # Configuration (async)
    api_url = await config.get("api_url", default="https://api.example.com")
    await config.set("api_url", "https://api.example.com")

    # Secrets (stored encrypted in database)
    api_key = await config.get("api_key")
    await config.set("api_key", "secret_value", is_secret=True)

    # Integration with OAuth (async)
    integration = await integrations.get("Microsoft")
    if integration and integration.oauth:
        access_token = integration.oauth.access_token
        # Use access_token for API calls

    # File operations (async)
    await files.write("data/output.txt", "content")
    content = await files.read("data/output.txt")
```

    **SDK Methods**: All SDK methods are async and require `await`. Use `is_secret=True` for encrypted storage of sensitive values.

## Execution Modes

### Synchronous

Only recommended for endpoint-enabled workflows, which will use this mode by default. Returns result immediately.

```python
@workflow(execution_mode="sync", timeout_seconds=30)
async def quick_lookup(context: ExecutionContext, id: str):
    result = await database.get(id)
    return {"result": result}
```

### Asynchronous

Best for long-running operations (> 30 seconds) and default unless using a workflow as an endpoint. Queued for background execution and will return realtime updates in the UI.

```python
@workflow(execution_mode="async", timeout_seconds=1800)
async def bulk_import(context: ExecutionContext, csv_url: str):
    items = await fetch_csv(csv_url)
    for item in items:
        await import_item(item)
    return {"imported": len(items)}
```

### Scheduled

Run automatically on a schedule using cron expressions.

```python
@workflow(schedule="0 9 * * *")  # Daily at 9 AM UTC
async def daily_report():
    """Generate and send daily report."""
    report = await generate_report()
    await send_report(report)
    return {"status": "sent"}
```

    You shouldn't have to think about this very much, with the exception of
    scheduled jobs.

## Data Providers

Provide dynamic options for dropdowns. Parameters are derived from function signatures:

1. Create a data provider:

    ```python
    from bifrost import data_provider

    @data_provider(cache_ttl_seconds=600)
    async def get_departments() -> list[dict]:
        """List available departments."""
        return [
            {"label": "Engineering", "value": "eng"},
            {"label": "Sales", "value": "sales"}
        ]
    ```

2. Create a data provider with parameters:

    ```python
    @data_provider
    async def get_users_by_dept(department: str) -> list[dict]:
        """Get users filtered by department."""
        users = await fetch_users(department)
        return [{"label": u.name, "value": u.id} for u in users]
    ```

3. Reference in forms via `data_provider_id` in the form field definition (see Forms documentation).

## Return Values

Always return a dictionary:

  
    ```python
    return {"success": True, "result": data}
    ```
  

  
    ```python
    # Workflow still succeeds, but indicates failure
    return {"success": False, "error": "User not found"}
    ```
  

  
    ```python
    return {
        "user": {"id": "123", "email": "user@example.com"},
        "items": [1, 2, 3]
    }
    ```
  

## Error Handling

Exceptions are automatically caught and handled by the execution engine. You can optionally return `{"success": False}` to indicate partial failures:

```python
import logging
from bifrost import workflow

logger = logging.getLogger(__name__)

@workflow
async def create_user(email: str, name: str):
    """Create a new user in the system."""
    # Raised exceptions are automatically caught and logged
    user = await create_user_in_system(email, name)
    logger.info(f"Created user: {user.id}")
    return {"user_id": user.id}

    # Or indicate partial failure (execution status: COMPLETED_WITH_ERRORS)
    # return {"success": False, "error": "User created but email failed"}
```

**Exception Handling**: Raised exceptions automatically mark the execution as FAILED. Returning `{"success": False}` marks it as COMPLETED_WITH_ERRORS.

## Logging

Use Python's logging module for visibility into execution:

```python
import logging
from bifrost import workflow

logger = logging.getLogger(__name__)

@workflow
async def process_data(items: list):
    """Process a list of data items."""
    logger.debug("Starting detailed processing...")  # Hidden from users
    logger.info(f"Processing {len(items)} items...")  # Visible to users
    logger.warning("Item 5 failed, continuing...")   # Visible to users
    logger.error("Critical failure detected")        # Visible to users
```

**Log Visibility**: `logger.debug()` is only visible to developers. All other levels (`info`, `warning`, `error`) are visible to users who execute workflows from forms.

## Best Practices

-   **Single Responsibility**: One workflow, one task. Keep workflows focused and composable.
-   **Validate Early**: Check inputs before processing to fail fast and provide clear feedback.
-   **Log for Users**: Use `logger.info()` for user-facing progress updates. Use `logger.debug()` for developer debugging.
-   **Let Exceptions Bubble**: Raised exceptions are automatically handled - no need to catch and return error dicts.
-   **Use Type Hints**: Enable IDE autocomplete and error detection with proper typing.
-   **Avoid Secrets in Returns**: Never return credentials or PII in workflow results.

## Common Patterns

### List Processing

```python
async def process_items(context: ExecutionContext, items: list):
    results = []
    errors = []

    for item in items:
        try:
            result = await process_item(item)
            results.append(result)
        except Exception as e:
            errors.append({"item": item, "error": str(e)})

    return {
        "processed": len(results),
        "failed": len(errors),
        "results": results,
        "errors": errors
    }
```

### Chained Operations

```python
async def create_user_with_license(context: ExecutionContext, email: str, sku: str):
    # Step 1
    logger.info("Creating user...")
    user = await create_user(email)

    # Step 2
    logger.info("Assigning license...")
    await assign_license(user.id, sku)

    return {"user_id": user.id, "license": sku}
```

## Next Steps

-   [Using Decorators](/how-to-guides/workflows/using-decorators) - Advanced decorator features
-   [Error Handling](/how-to-guides/workflows/error-handling) - Comprehensive error patterns
-   [SDK Reference](/sdk-reference/sdk/bifrost-module) - Full API documentation