# Cascading Dropdowns

Create dropdowns that update based on other field selections

---

Cascading dropdowns let users select from filtered options based on previous selections. For example: Department → Manager, or Country → State → City.

## What You'll Build

A form where selecting a department dynamically populates a managers dropdown with only managers from that department.

## Prerequisites

-   Form with linked workflow
-   Basic understanding of data providers

## Create the Data Providers

**Step 1**: Create department provider (`workspace/data_providers/departments.py`):

```python
from bifrost import data_provider

@data_provider(cache_ttl_seconds=3600)  # Cache 1 hour
async def get_departments() -> list[dict]:
    """List all departments."""
    return [
        {"label": "Engineering", "value": "eng"},
        {"label": "Sales", "value": "sales"},
        {"label": "Support", "value": "support"}
    ]
```

**Step 2**: Create managers provider with department parameter (parameters derived from function signature):

```python
from bifrost import data_provider

@data_provider
async def get_managers_by_dept(department: str) -> list[dict]:
    """Get managers filtered by department."""
    managers = await db.query(
        "SELECT id, name FROM users WHERE department = ? AND is_manager = true",
        department
    )
    return [
        {"label": mgr["name"], "value": mgr["id"]}
        for mgr in managers
    ]
```

    Parameters are automatically derived from the function signature. The
    managers list will update when the department field changes.

## Configure the Workflow

Create a workflow with the parameters:

```python
from bifrost import workflow

@workflow
async def assign_to_manager(department: str, manager: str) -> dict:
    """Assign work to a manager."""
    return {
        "department": department,
        "manager_id": manager,
        "assigned": True
    }
```

## Configure Form Fields

In the form JSON, link fields to data providers using `data_provider_id` and `data_provider_inputs`:

```json
{
  "form_schema": {
    "fields": [
      {
        "name": "department",
        "type": "select",
        "label": "Department",
        "data_provider_id": "uuid-of-get-departments"
      },
      {
        "name": "manager",
        "type": "select",
        "label": "Manager",
        "data_provider_id": "uuid-of-get-managers-by-dept",
        "data_provider_inputs": {
          "department": "{{department}}"
        }
      }
    ]
  }
}
```

    **Field Reference** with `{{department}}` passes the selected department value to the
    managers data provider automatically.

## Test It

1. Save the form
2. Click **Launch**
3. Select a department
4. Watch the managers dropdown populate with filtered results
5. Select a manager and submit

## Advanced Patterns

### Three-Level Cascade (Country → State → City)

```python
from bifrost import data_provider

@data_provider
async def get_countries() -> list[dict]:
    """List countries."""
    return [
        {"label": "United States", "value": "us"},
        {"label": "Canada", "value": "ca"}
    ]

@data_provider
async def get_states(country: str) -> list[dict]:
    """Get states for a country."""
    states = await db.query(
        "SELECT * FROM states WHERE country_code = ?",
        country
    )
    return [{"label": s.name, "value": s.code} for s in states]

@data_provider
async def get_cities(state: str) -> list[dict]:
    """Get cities for a state."""
    cities = await db.query(
        "SELECT * FROM cities WHERE state_code = ?",
        state
    )
    return [{"label": c.name, "value": c.id} for c in cities]
```

Configure in form JSON:

```json
{
  "form_schema": {
    "fields": [
      {
        "name": "country",
        "type": "select",
        "label": "Country",
        "data_provider_id": "uuid-of-get-countries"
      },
      {
        "name": "state",
        "type": "select",
        "label": "State",
        "data_provider_id": "uuid-of-get-states",
        "data_provider_inputs": {
          "country": "{{country}}"
        }
      },
      {
        "name": "city",
        "type": "select",
        "label": "City",
        "data_provider_id": "uuid-of-get-cities",
        "data_provider_inputs": {
          "state": "{{state}}"
        }
      }
    ]
  }
}
```

### Multiple Parameters

Pass multiple field values to a provider:

```python
@data_provider
async def get_filtered_products(category: str, price_range: str) -> list[dict]:
    """Get products filtered by category and price range."""
    products = await db.query(
        "SELECT * FROM products WHERE category = ? AND price_range = ?",
        category, price_range
    )
    return [{"label": p.name, "value": p.id} for p in products]
```

In form Data Provider Inputs:

```json
{
  "data_provider_inputs": {
    "category": "{{category}}",
    "price_range": "{{price_range}}"
  }
}
```

### Static + Field Reference

Mix static values with field references:

```python
@data_provider
async def get_regional_managers(department: str, region: str) -> list[dict]:
    """Get managers for a department in a region."""
    return await fetch_managers(department, region)
```

In form Data Provider Inputs:

```json
{
  "data_provider_inputs": {
    "department": "{{department}}",
    "region": "west_coast"
  }
}
```

### Organization-Scoped Cascading

Use the context proxy to access organization:

```python
from bifrost import data_provider, context

@data_provider
async def get_org_departments() -> list[dict]:
    """Get departments for current organization."""
    return await db.query(
        "SELECT * FROM departments WHERE org_id = ?",
        context.org_id
    )

@data_provider
async def get_org_managers(department: str) -> list[dict]:
    """Get managers for current organization and department."""
    return await db.query(
        "SELECT * FROM users WHERE org_id = ? AND department = ? AND is_manager = true",
        context.org_id, department
    )
```

### Empty State Handling

Show helpful message when no options available:

```python
@data_provider
async def get_managers_by_dept(department: str) -> list[dict]:
    """Get managers filtered by department."""
    managers = await db.query(
        "SELECT * FROM users WHERE department = ? AND is_manager = true",
        department
    )

    if not managers:
        return [{"label": "No managers in this department", "value": "", "disabled": True}]

    return [{"label": m.name, "value": m.id} for m in managers]
```

## Troubleshooting

**Dropdown not updating**: Verify `data_provider_inputs` configuration. Field references must use `{{field_name}}` syntax.

**Empty dropdown**: Check provider returns correct format with `label` and `value`. Test provider independently.

**Slow updates**: Increase cache TTL on parent provider. Use shorter TTL on dependent provider for freshness.

## Best Practices

-   **Cache parent providers**: Long TTL on rarely-changing data (departments, countries)
-   **Short cache on dependent providers**: Balance freshness with performance
-   **Limit results**: Return max ~100 options per dropdown
-   **Show loading states**: Dependent providers may take time to fetch
-   **Test edge cases**: What if parent selection is cleared?

## Next Steps

-   [Visibility Rules](/how-to-guides/forms/visibility-rules) - Show/hide fields conditionally
-   [HTML Content](/how-to-guides/forms/html-content) - Display dynamic content