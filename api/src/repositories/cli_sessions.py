"""
CLI Session Repository

Database operations for CLI debugging sessions.
Handles CRUD operations for CLISession table.
"""

import logging
from datetime import datetime, timedelta
from typing import Any
from uuid import UUID

from sqlalchemy import desc, select
from sqlalchemy.orm import selectinload

from src.models.orm import CLISession
from src.repositories.base import BaseRepository

logger = logging.getLogger(__name__)

# TTL for session "connected" status (10 seconds since last heartbeat)
SESSION_CONNECTED_THRESHOLD_SECONDS = 10

# Default TTL for sessions (8 hours)
SESSION_TTL_HOURS = 8


class CLISessionRepository(BaseRepository[CLISession]):
    """Repository for CLI session operations."""

    model = CLISession

    async def create_session(
        self,
        session_id: UUID,
        user_id: UUID,
        file_path: str,
        workflows: list[dict[str, Any]],
        selected_workflow: str | None = None,
    ) -> CLISession:
        """
        Create or update a CLI session.

        If a session with the given ID already exists, updates it.
        Otherwise creates a new session.

        Args:
            session_id: Session UUID (generated by CLI)
            user_id: User ID who owns this session
            file_path: Absolute path to workflow file
            workflows: List of registered workflows
            selected_workflow: Pre-selected workflow name

        Returns:
            Created or updated CLISession
        """
        now = datetime.utcnow()
        expires_at = now + timedelta(hours=SESSION_TTL_HOURS)

        # Check if session already exists
        existing = await self.get_by_id(session_id)

        if existing:
            # Update existing session
            existing.file_path = file_path
            existing.workflows = workflows
            existing.selected_workflow = selected_workflow
            existing.last_seen = now
            existing.expires_at = expires_at
            existing.pending = False
            existing.params = None
            await self.session.flush()
            await self.session.refresh(existing)
            return existing

        # Create new session
        session = CLISession(
            id=session_id,
            user_id=user_id,
            file_path=file_path,
            workflows=workflows,
            selected_workflow=selected_workflow,
            last_seen=now,
            expires_at=expires_at,
        )
        return await self.create(session)

    async def get_session_with_executions(
        self,
        session_id: UUID,
    ) -> CLISession | None:
        """
        Get session with eagerly loaded executions.

        Args:
            session_id: Session UUID

        Returns:
            CLISession with executions loaded, or None
        """
        result = await self.session.execute(
            select(CLISession)
            .where(CLISession.id == session_id)
            .options(selectinload(CLISession.executions))
        )
        return result.scalar_one_or_none()

    async def get_user_sessions(
        self,
        user_id: UUID,
        include_expired: bool = False,
        limit: int = 50,
    ) -> list[CLISession]:
        """
        Get all sessions for a user.

        Args:
            user_id: User UUID
            include_expired: Whether to include expired sessions
            limit: Maximum number of sessions to return

        Returns:
            List of CLISessions ordered by created_at desc
        """
        query = (
            select(CLISession)
            .where(CLISession.user_id == user_id)
            .options(selectinload(CLISession.executions))
            .order_by(desc(CLISession.created_at))
            .limit(limit)
        )

        if not include_expired:
            query = query.where(
                (CLISession.expires_at.is_(None)) |
                (CLISession.expires_at > datetime.utcnow())
            )

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def update_last_seen(self, session_id: UUID) -> CLISession | None:
        """
        Update session's last_seen timestamp (heartbeat).

        Args:
            session_id: Session UUID

        Returns:
            Updated CLISession or None if not found
        """
        session = await self.get_by_id(session_id)
        if session:
            session.last_seen = datetime.utcnow()
            session.expires_at = datetime.utcnow() + timedelta(hours=SESSION_TTL_HOURS)
            await self.session.flush()
            return session
        return None

    async def set_pending(
        self,
        session_id: UUID,
        workflow_name: str,
        params: dict[str, Any],
    ) -> CLISession | None:
        """
        Set session to pending state with execution params.

        Called when user clicks "Continue" in web UI.

        Args:
            session_id: Session UUID
            workflow_name: Selected workflow to execute
            params: Workflow parameters

        Returns:
            Updated CLISession or None if not found
        """
        session = await self.get_by_id(session_id)
        if session:
            session.selected_workflow = workflow_name
            session.params = params
            session.pending = True
            session.expires_at = datetime.utcnow() + timedelta(hours=SESSION_TTL_HOURS)
            await self.session.flush()
            return session
        return None

    async def clear_pending(self, session_id: UUID) -> CLISession | None:
        """
        Clear pending state after CLI picks up execution.

        Args:
            session_id: Session UUID

        Returns:
            Updated CLISession or None if not found
        """
        session = await self.get_by_id(session_id)
        if session:
            session.pending = False
            session.expires_at = datetime.utcnow() + timedelta(hours=SESSION_TTL_HOURS)
            await self.session.flush()
            return session
        return None

    async def get_session_for_user(
        self,
        session_id: UUID,
        user_id: UUID,
    ) -> CLISession | None:
        """
        Get session if it belongs to the specified user.

        Args:
            session_id: Session UUID
            user_id: User UUID

        Returns:
            CLISession if found and belongs to user, None otherwise
        """
        result = await self.session.execute(
            select(CLISession)
            .where(
                CLISession.id == session_id,
                CLISession.user_id == user_id,
            )
            .options(selectinload(CLISession.executions))
        )
        return result.scalar_one_or_none()

    @staticmethod
    def is_connected(session: CLISession) -> bool:
        """
        Check if CLI is actively connected based on last_seen.

        Args:
            session: CLISession to check

        Returns:
            True if CLI is connected (last_seen within threshold)
        """
        if session.last_seen is None:
            return False
        threshold = datetime.utcnow() - timedelta(seconds=SESSION_CONNECTED_THRESHOLD_SECONDS)
        return session.last_seen > threshold

    async def cleanup_expired_sessions(self) -> int:
        """
        Delete sessions that have expired.

        Returns:
            Number of sessions deleted
        """
        from sqlalchemy import delete

        now = datetime.utcnow()
        result = await self.session.execute(
            delete(CLISession).where(
                CLISession.expires_at.is_not(None),
                CLISession.expires_at < now,
            )
        )
        return result.rowcount or 0
